#Область ОписаниеПеременных

Перем _Лог;
Перем ГенераторЗамечаний_Generic_Issue;

#КонецОбласти

Процедура ПриСозданииОбъекта(Знач пЛог, Знач пИспользоватьОтносительныеПути = Ложь)
	
	_Лог = пЛог;
	ГенераторЗамечаний_Generic_Issue = Новый ГенераторЗамечаний_Generic_Issue(пЛог, пИспользоватьОтносительныеПути);

КонецПроцедуры

Функция ДанныеФайлаПоТаблицеРезультатов(Знач пТаблицаРезультатовПроверки) Экспорт
	
	результатПроверки = РезультатПроверкиОбщийФорматОтчета(пТаблицаРезультатовПроверки);
	
	_Лог.Информация(
		"Подготовлено к записи в джсон ошибок: %1, правил: %2",
		результатПроверки.issues.Количество(),
		результатПроверки.rules.Количество());
	
	Возврат результатПроверки;
	
КонецФункции

Функция РезультатПроверкиОбщийФорматОтчета(пТаблицаРезультатовПроверки)
	
	шаблонПравил = ПодготовленныеПравила();

	результат = Новый Структура;
	результат.Вставить("issues", Новый Массив);
	результат.Вставить("rules", Новый Массив);
	
	источникПроверки = ГенераторЗамечаний_Generic_Issue.ИсточникПроверки();
	
	существующиеПравила = Новый Соответствие;
	
	Для Каждого цПравило Из шаблонПравил Цикл
		
		существующиеПравила.Вставить(цПравило.id, цПравило);
		
	КонецЦикла;
	
	добавленныеПравила = Новый Соответствие;

	Для Каждого цСтрока Из пТаблицаРезультатовПроверки Цикл
		
		ruleId = цСтрока.ИдентификаторПравила;
		
		Если НЕ ЗначениеЗаполнено(ruleId) Тогда
			_Лог.Предупреждение("Пустой ruleId для %1 / %2", ГенераторЗамечаний_Generic_Issue.СообщениеОбОшибке(цСтрока), цСтрока.Правило);
		КонецЕсли;
		
		структОшибка = Новый Структура;
		структОшибка.Вставить("ruleId", ruleId);
		структОшибка.Вставить("effortMinutes", ЗатратыНаИсправление(цСтрока));
		структОшибка.Вставить("primaryLocation", ГенераторЗамечаний_Generic_Issue.МестонахождениеОшибки(цСтрока));
		структОшибка.Вставить("secondaryLocations", ВторостепенноеМестонахождение(цСтрока));
		
		результат.issues.Добавить(структОшибка);
		
		Если добавленныеПравила[ruleId] = Истина Тогда
			Продолжить;
		КонецЕсли;

		добавленныеПравила.Вставить(ruleId, Истина);
		
		Если Не существующиеПравила[ruleId] = Неопределено Тогда
			результат.rules.Добавить(существующиеПравила[ruleId]);
			Продолжить;
		КонецЕсли;
		
		структПравила = Новый Структура;
		структПравила.Вставить("engineId", источникПроверки);
		структПравила.Вставить("id", ruleId);
		структПравила.Вставить("name", цСтрока.НаименованиеПравила);
		структПравила.Вставить("description", цСтрока.НаименованиеПравила);
		структПравила.Вставить("cleanCodeAttribute", АтрибутЧистогоКода(цСтрока));
		структПравила.Вставить("impacts", Новый Массив);
		
		ДанныеКачества = Новый Структура;
		ДанныеКачества.Вставить("softwareQuality", КачествоПО(цСтрока));
		ДанныеКачества.Вставить("severity", ВажностьОшибки(цСтрока));
		структПравила.impacts.Добавить(ДанныеКачества);
		
		результат.rules.Добавить(структПравила);
		
		существующиеПравила.Вставить(ruleId, структПравила);
		
	КонецЦикла;
	
	Возврат результат;
	
КонецФункции

Функция ПодготовленныеПравила()
	
	имяФайла = ОбъединитьПути("dict", "rules_Generic_issue.json");
	
	Файл = Новый Файл(ОбъединитьПути(ТекущийСценарий().Каталог, "..", "..", имяФайла));
	Если Не Файл.Существует() Тогда
		_Лог.Предупреждение("Файл %1 с правилами по умолчанию не существует", имяФайла);
		Возврат Новый Массив;
	КонецЕсли;
	
	Попытка
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.ОткрытьФайл(Файл.ПолноеИмя, "UTF-8");
		Данные = ПрочитатьJSON(ЧтениеJSON, Ложь);
	Исключение
		_Лог.Предупреждение("Ошибка чтения правил %1
			|%2", Файл.ПолноеИмя, ОписаниеОшибки());
		Возврат Новый Массив;
	КонецПопытки;
	
	правила = Данные["rules"];
	
	Если Не ТипЗнч(правила) = Тип("Массив") Тогда
		_Лог.Предупреждение("Неверная структура правил в файле %1", Файл.ПолноеИмя);
		Возврат Новый Массив;
	КонецЕсли;
	
	Возврат правила;
	
КонецФункции

Функция АтрибутЧистогоКода(Знач пДанные)
	
	// BSLLS:DuplicateStringLiteral-off
	АтрибутПоУмолчанию = "CONVENTIONAL";
	
	Соответствие = Новый Соответствие;
	Соответствие.Вставить("Ошибка", "LOGICAL");
	Соответствие.Вставить("Ошибки конфигурации", "LOGICAL");
	Соответствие.Вставить("Предупреждение", "CONVENTIONAL");
	Соответствие.Вставить("Безопасность", "TRUSTWORTHY");
	Соответствие.Вставить("Производительность", "EFFICIENT");
	Соответствие.Вставить("Переносимость", "MODULAR");
	Соответствие.Вставить("Разработка и использование библиотек", "CONVENTIONAL");
	Соответствие.Вставить("Стандарты кодирования", "FORMATTED");
	Соответствие.Вставить("Стандарты разработки интерфейсов", "CONVENTIONAL");
	Соответствие.Вставить("Орфография", "CONVENTIONAL");
	Соответствие.Вставить("Критическая проблема целостности данных", "LOGICAL");
	
	Атрибут = Соответствие.Получить(пДанные.Тип);
	
	Если Атрибут = Неопределено Тогда
		
		// В edt 2023.2.4 другой порядок колонок Тип и Серьезность относительно метода edtExport.ИменаПолей.
		// Так же некоторые диагностики пишут Тип в Серьезность. Например "Функция не определена", "Не назначен обработчик для события жлемента формы".
		Атрибут = Соответствие.Получить(пДанные.Серьезность);
		
		Если Атрибут = Неопределено Тогда
			Атрибут = АтрибутПоУмолчанию;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Атрибут;
	
КонецФункции

Функция КачествоПО(Знач пДанные)
	
	// BSLLS:DuplicateStringLiteral-off
	
	// MAINTAINABILITY,RELIABILITY,SECURITY
	КачествоПОПоУмолчанию = "MAINTAINABILITY";
	
	Соответствие = Новый Соответствие;
	Соответствие.Вставить("Ошибка", "RELIABILITY");
	Соответствие.Вставить("Ошибки конфигурации", "RELIABILITY");
	Соответствие.Вставить("Предупреждение", "MAINTAINABILITY");
	Соответствие.Вставить("Безопасность", "SECURITY");
	Соответствие.Вставить("Производительность", "RELIABILITY");
	Соответствие.Вставить("Переносимость", "MAINTAINABILITY");
	Соответствие.Вставить("Разработка и использование библиотек", "MAINTAINABILITY");
	Соответствие.Вставить("Стандарты кодирования", "MAINTAINABILITY");
	Соответствие.Вставить("Стандарты разработки интерфейсов", "MAINTAINABILITY");
	Соответствие.Вставить("Орфография", "MAINTAINABILITY");
	Соответствие.Вставить("Критическая проблема целостности данных", "RELIABILITY");
	
	КачествоПО = Соответствие.Получить(пДанные.Тип);
	
	Если КачествоПО = Неопределено Тогда
		
		// В edt 2023.2.4 другой порядок колонок Тип и Серьезность относительно метода edtExport.ИменаПолей.
		// Так же некоторые диагностики пишут Тип в Серьезность. Например "Функция не определена", "Не назначен обработчик для события жлемента формы".
		КачествоПО = Соответствие.Получить(пДанные.Серьезность);
		
		Если КачествоПО = Неопределено Тогда
			КачествоПО = КачествоПОПоУмолчанию;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат КачествоПО;
	
КонецФункции

Функция ВажностьОшибки(Знач пДанные)
	
	// HIGH,MEDIUM,LOW
	ВажностьПоУмолчанию = "MEDIUM";
	
	Соответствие = Новый Соответствие;
	Соответствие.Вставить("Блокирующая", "HIGH");
	Соответствие.Вставить("Критическая", "HIGH");
	Соответствие.Вставить("Значительная", "MEDIUM");
	Соответствие.Вставить("Незначительная", "LOW");
	Соответствие.Вставить("Тривиальная", "LOW");
	
	Важность = Соответствие.Получить(пДанные.Серьезность);
	
	Если Важность = Неопределено Тогда
		
		// В edt 2023.2.4 другой порядок колонок Тип и Серьезность относительно метода edtExport.ИменаПолей.
		// Так же некоторые диагностики пишут Тип в Серьезность. Например "Функция не определена", "Не назначен обработчик для события жлемента формы".
		Важность = Соответствие.Получить(пДанные.Тип);
		
		Если Важность = Неопределено Тогда
			Важность = ВажностьПоУмолчанию;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Важность;
	
КонецФункции

Функция ЗатратыНаИсправление(Знач пДанные)
	
	Возврат 0;
	
КонецФункции

Функция ВторостепенноеМестонахождение(Знач пДанные)
	
	Возврат Новый Массив;
	
КонецФункции